// Generated by CoffeeScript 1.10.0
(function() {
  var FeedParser, Snok, request,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  request = require('request');

  FeedParser = require('feedparser');

  module.exports = Snok = (function() {
    Snok.prototype.MAX_SAVED_ITEMS = 1000;

    function Snok(feeds, triggers, callback, log) {
      this.feeds = feeds;
      this.triggers = triggers;
      this.callback = callback;
      this.log = log != null ? log : false;
      this._examine = bind(this._examine, this);
      this._fetchAndParse = bind(this._fetchAndParse, this);
      this.setUserAgent = bind(this.setUserAgent, this);
      this.sniff = bind(this.sniff, this);
      this.checkedItems = [];
      this.userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36';
    }

    Snok.prototype.sniff = function() {
      var feed, j, len, ref, results;
      ref = this.feeds;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        feed = ref[j];
        results.push(this._fetchAndParse(feed));
      }
      return results;
    };

    Snok.prototype.setUserAgent = function(userAgent) {
      return this.userAgent = userAgent;
    };

    Snok.prototype._fetchAndParse = function(feed) {
      var feedParser, options, self;
      self = this;
      feedParser = new FeedParser;
      options = {
        url: feed,
        headers: {
          'User-Agent': this.userAgent,
          'Accept': 'text/html,application/xhtml+xml'
        }
      };
      request.get(options).on('error', function(error) {
        if (self.log) {
          return console.error(error);
        }
      }).on('response', function(response) {
        if (response.statusCode !== 200) {
          if (self.log) {
            return console.error("Server responded with " + response.statusCode + "...");
          }
        }
      }).pipe(feedParser);
      return feedParser.on('error', function(error) {
        if (self.log) {
          return console.error(error);
        }
      }).on('readable', function() {
        var item, results;
        results = [];
        while (item = this.read()) {
          results.push(self._examine(item));
        }
        return results;
      });
    };

    Snok.prototype._examine = function(item) {
      var containsTrigger, first, i, j, len, ref, ref1, ref2, ref3, second, text, trigger;
      if (!item.guid) {
        item.guid = item.link;
      }
      if (ref = item.guid, indexOf.call(this.checkedItems, ref) >= 0) {
        return;
      }
      if (this.checkedItems.length > this.MAX_SAVED_ITEMS) {
        this.checkedItems.shift();
      }
      this.checkedItems.push(item.guid);
      containsTrigger = false;
      text = ((ref1 = item.title) != null ? ref1.toLowerCase() : void 0) || '';
      text += ((ref2 = item.description) != null ? ref2.toLowerCase() : void 0) || '';
      ref3 = this.triggers;
      for (j = 0, len = ref3.length; j < len; j++) {
        trigger = ref3[j];
        if (trigger.includes('&&')) {
          i = trigger.indexOf('&&');
          first = trigger.substring(0, i).trim().toLowerCase();
          second = trigger.substring(i + 2).trim().toLowerCase();
          if (text.includes(first) && text.includes(second)) {
            containsTrigger = true;
            break;
          }
        } else if (text.includes(trigger.toLowerCase())) {
          containsTrigger = true;
          break;
        }
      }
      if (containsTrigger) {
        return this.callback(item);
      }
    };

    return Snok;

  })();

}).call(this);
